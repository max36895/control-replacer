# Скрипт для автозамены

Скрипт предназначен для замены всех вхождений контролов, а также позволяет выполнить замену, когда контрол переносится
из одного модуля в другой. Также скрипт позволяет переименовать нужную опцию у контрола, переименовать/удалить css переменную или класс, либо передать свою настройку для замены.

Готовый скрипт можно скачать из репозитория, либо собрать самому. Для этого нужно скачать проект, выполнить `npm i`
и `npm run build`

## Как работает

Необходимо запустить файл `dist/replacer.js`, а также создать json файл с настройкой для скрипта

## Запуск

Переименовывания контролов:

```bash
node replacer.js config.json
```

Переименовывания опций:

```bash
node replacer.js replaceOpt config.json
```

Переименовывания css переменных или классов:

```bash
node replacer.js cssReplace config.json
```

Свое переименование:

```bash
node replacer.js customReplace config.json
```

Сброс правок, на случай если скрипт запущен ошибочно, либо с некорректным config.json:

```bash
node replacer.js resetGit config.json
```

## JSON файл настроек

### Описание

Описание файла конфигурации для переименовывания контролов:

```json
{
  "path": "Путь к репозиториям, где нужно выполнить замену",
  "replaces": [
    {
      "module": "Текущее имя модуля",
      "newModule": "Новое имя модуля. Стоит использовать когда весь модуль со всеми контролами переносится",
      "controls": [
        {
          "name": "Текущее имя контрола",
          "newName": "Новое имя контрола",
          "newModuleName": "Новое имя модуля"
        }
      ]
    }
  ],
  "maxFileSize": "Максимальный размер файла. По умолчанию 50"
}
```

Описание файла конфигурации для переименовывания опций:

```json
{
  "path": "Путь к репозиториям, где нужно выполнить замену",
  "replaces": [
    {
      "thisOpt": "Текущее имя опции",
      "newOpt": "Новое имя опции",
      "module": "Имя модуля, для которого нужно осуществить переименовывание",
      "control": "Имя контрола, в котором нужно переименовать опцию"
    }
  ],
  "maxFileSize": "Максимальный размер файла. По умолчанию 50"
}
```

Описание файла конфигурации для переименовывания css переменных или классов:

```json
{
  "path": "Путь к репозиториям, где нужно выполнить замену",
  "replaces": [
    {
      "varName": "Текущее имя переменной или класса",
      "newVarName": "Новое имя переменной или класса",
      "isRemove": "Класс или переменная полностью удаляется"
    }
  ],
  "maxFileSize": "Максимальный размер файла. По умолчанию 50"
}
```

Описание файла конфигурации для кастомного переименовывания:

```json
{
  "path": "Путь к репозиториям, где нужно выполнить замену",
  "replaces": [
    {
      "reg": "Регулярное выражение",
      "flag": "Флаг для регулярного выражения. По умолчанию g",
      "replace": "То как производится замена"
    }
  ],
  "maxFileSize": "Максимальный размер файла. По умолчанию 50"
}
```

При кастомной замене стоит правильно указывать значение в replace!
Замена осуществляется следующим образом:

```js
str.replace((new RegExp(congig.reg, config.flag || 'g')), config.replace);
```

Для сброса правок, можно указать любой их указанных выше файлов конфигурации. Либо создать отдельный, но важно чтобы
было указано поле `path`

### Примеры файлов конфигурации

Замена Controls/toggle:Tumbler на Controls/toggle:NewTumbler

```json
{
  "path": "",
  "replaces": [
    {
      "module": "Controls/toggle",
      "controls": [
        {
          "name": "Tumbler",
          "newName": "NewTumbler"
        }
      ]
    }
  ]
}
```

Замена Controls/list:Button на Controls-button/list:Button.
```json
{
  "path": "",
  "replaces": [
    {
      "module": "Controls/list",
      "controls": [
        {
          "name": "Button",
          "newModuleName": "Controls-button/list"
        }
      ]
    }
  ]
}
 ```

Замена Controls/toggle:Tumbler на Controls-toggle/Tumbler. Обратите внимание на `newName`, если свойство не
указывать, то произойдет переименование модуля(`Controls-toggle/Tumbler:Tumbler`), но при указании пустой строки,
контрол подключается как модуль.

```json
{
  "path": "",
  "replaces": [
    {
      "module": "Controls/toggle",
      "controls": [
        {
          "name": "Tumbler",
          "newName": "",
          "newModuleName": "Controls-toggle/Tumbler"
        }
      ]
    }
  ]
}
 ```

Замена опции myClassName на className у контрола Controls/toggle:Toggle

```json
{
  "path": "",
  "replaces": [
    {
      "thisOpt": "myClassName",
      "newOpt": "className",
      "module": "Controls/toggle",
      "control": "Toggle"
    }
  ]
}
```

### Дополнительно

Важно чтобы в module и newModuleName разделение было сделано через `/` иначе возможна некорректная работа. Также в `controls` можно не указывать newName и newModuleName, в таком случае значения поставятся из name и module. При этом, одно из значений
должно быть заполнено, иначе скрипт посчитает что правки не нужны и завершит обработку.

Подобное сделано для удобства, когда переименовывается только модуль или контролл.

При использовании кастомной замены, перепроверьте получаемый результат в консоли, и только после этого запускайте
скрипт. В противном случае можно получить не тот результат, который ожидался, и придется откатывать изменения.

## Что корректно работает

Скрипт автоматически вносит правки в wml файлы. А также может вносить правки в ts, tsx и другие файлы.

Корректно обрабатываются следующие сценарии:

```js
import {Tumbler} from 'Controls/toggle';

<Tumbler/>
```

```js
import {Tumbler as View} from 'Controls/toggle';

<View/>
```

```js
import {default as toggle} from 'Controls/toggle';

<toggle.Tumbler/>
```

```js
import {Tumbler, Switch} from 'Controls/toggle';

<Tumbler/>
<Switch/>
```

Если из исходной библиотеки выносится 1 контрол, то скрипт сам создаст или найдет нужный импорт, и поместит туда новый
контрол

Что касается переименовывания опций, то скрипт обрабатывает практически все случаи. И работает как с wml, так и с tsx.

При переименовывании css переменных или классов корректно отрабатываются все случаи связанные с переменными. Также если указан isRemove=true, то определение переменной удалится.

## Что нестабильно работает с заменой контролов

Сейчас есть проблемы с импортом следующего вида:

```js
import * as toggle from 'Controls/toggle';
```

Скрипт самостоятельно не сможет обработать подобные сценарии, на что кинет ошибку. Но при этом скрипт сможет внести
правки по использованию контрола, и заменит

```js
<toggle.Name>
```

на

```js
<toggle.NewName>
```

Скрипт не тронет сам импорт, так как не знает нужно его заменить и как. Если вы полностью переносите весь модуль, то
можно указать это название в `replaces.newModule`, в таком случае скрипт заменит импорт для модуля. Свойство стоит
использовать тогда, когда полностью переименовывается модуль, в противном случае скрипт отработает некорректно.

Также если контрол использовался так `Controls.LoadingIndicator`, а нужно превратить его в `Controls.loading:Indicator`,
то скрипт самостоятельно не сможет подобное обработать, а любая попытка провернуть подобное может обернуться ошибками.
Возможно, когда-то подобный функционал появится, но на данный момент в нем нет необходимости.

## Что не корректно работает с переименовыванием опций
Скрипт не сможет обработать случаи, когда контрол вставляется в другой контрол в качестве шаблона с передачей опций.
```js
<Async templateName="Controls.toggle:Tumblet" templateOptions="{optionName: ...}"/>
```
и
```js
<Async templateName="Controls.toggle:Tumblet">
<ws:templateOptions optionName="..."/>
</Asynk>
```
Также не отработают случай с использование spread оператора
```js
<Tumbler {...{optionName: '...'}}/>
```

## Что не корректно работает с переименовыванием классов
Скрипт корректно отрабатывает все случае с заменой классов. Но могут возникнуть сложности, когда isRemove=true.
Скрипт не сможет корректно отработать в следующих конструкциях:
```css
.myClass .removeClass {
  ...
}
```
и
```css
.removeClass {
  ...
  .template {
    ...
  }
}
```
Данные конструкции скрипт пропустит, но выкинет ошибку, чтобы можно было вручную внести правку. Все остальные конструкции отрабатывают корректно.

## Дополнительно

Через скрипт можно переименовывать различные утилиты, но есть вероятность что будет проблемы в редких случаях(см "Что
нестабильно работает").

Скрипт проходится по всем файлам в директории, но не смотрит файлы больше 50mb, но можно настроить другое ограничение
используя `maxFileSize`(не рекомендуется устанавливать большие значения)

О найденных проблемах или идеях по улучшению можно
писать [мне](https://online.sbis.ru/person/5bf5b206-a664-422b-b5e2-41217142717a)