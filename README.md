# Скрипт для автозамены

Скрипт предназначен для замены всех вхождений контролов, а также позволяет выполнить замену, когда контрол переносится
из одного модуля в другой. Также скрипт позволяет переименовать нужную опцию у контрола, либо передать свою настройку
для замены.

Готовый скрипт можно скачать из репозитория, либо собрать самому. Для этого нужно скачать проект, выполнить `npm i`
и `npm run build`

## Как работает

Необходимо запустить файл `dist/replacer.js`, а также создать json файл с настройкой для скрипта

## Запуск

Для переименовывания контролов:

```bash
node replacer.js config.json
```

Для переименовывания опций:

```bash
node replacer.js replaceOpt config.json
```

Для своего переименовывания:

```bash
node replacer.js customReplace config.json
```

Для сброса правок:

```bash
node replacer.js resetGit config.json
```

## JSON файл настроек

### Описание

Описание файла конфигурации для переименовывания контролов:

```json
{
  "path": "Путь к репозиториям, где нужно выполнить замену",
  "replaces": [
    {
      "module": "Текущее имя модуля",
      "newModule": "Новое имя модуля. Стоит использовать когда весь модуль переносится",
      "controls": [
        {
          "name": "Текущее имя контрола",
          "newName": "Новое имя контрола",
          "newModuleName": "Новое имя модуля"
        }
      ]
    }
  ],
  "maxFileSize": "Максимальный размер файла. По умолчанию 50"
}
```

Описание файла конфигурации для переименовывания опций:

```json
{
  "path": "Путь к репозиториям, где нужно выполнить замену",
  "replaces": [
    {
      "thisOpt": "Текущее имя опции",
      "newOpt": "Новое имя опции",
      "module": "Имя модуля, для которого нужно осуществить переименовывание",
      "control": "Имя контрола, в котором нужно переименовать опцию"
    }
  ],
  "maxFileSize": "Максимальный размер файла. По умолчанию 50"
}
```

Описание файла конфигурации для кастомного переименовывания:

```json
{
  "path": "Путь к репозиториям, где нужно выполнить замену",
  "replaces": [
    {
      "reg": "Регулярное выражение",
      "flag": "Флаг для регулярного выражения. По умолчанию g",
      "replace": "То как производится замена"
    }
  ],
  "maxFileSize": "Максимальный размер файла. По умолчанию 50"
}
```

При кастомной замене стоит правильно указывать значение в replace!
Замена осуществляется следующим образом:

```js
str.replace((new RegExp(congig.reg, config.flag || 'g')), config.replace);
```

Для сброса правок, можно указать любой их указанных выше файлов конфигурации. Либо создать отдельный, но важно чтобы
было указано свойство `path`

### Примеры файлов конфигурации

Пример для замены Controls/toggle:Tumbler на Controls/toggle:NewTumbler Файл JSON

```json
{
  "path": "",
  "replaces": [
    {
      "module": "Controls/toggle",
      "controls": [
        {
          "name": "Tumbler",
          "newName": "NewTumbler"
        }
      ]
    }
  ]
}
```

Если надо заменить Controls/toggle:Tumbler на Controls/Tumbler. Обратите внимание на `newName`, если свойство не
указывать, то просто произойдет переименование модуля(`Controls/Tumbler:Tumbler`), но при указании пустой строки,
контрол подключается как модуль.

```json
{
  "path": "",
  "replaces": [
    {
      "module": "Controls/toggle",
      "controls": [
        {
          "name": "Tumbler",
          "newName": "",
          "newModuleName": "Tumbler"
        }
      ]
    }
  ]
}
 ```

Пример для замены опции myClassName на className у контрола Controls/toggle:Toggle

```json
{
  "path": "",
  "replaces": [
    {
      "thisOpt": "myClassName",
      "newOpt": "className",
      "module": "Controls/toggle",
      "control": "Toggle"
    }
  ]
}
```

### Дополнительно

Важно чтобы в module разделение было сделано через `/` иначе возможна некорректная работа. Также в `controls` можно не
указывать newName и newModuleName, в таком случае значения поставятся из name и module. Но при этом, одно из значений
должно быть заполнено, иначе скрипт посчитает что правки не нужны и завершит обработку.

Подобное сделано для удобства, когда переименовывается только модуль или контролл.

При использовании кастомной замены, перепроверьте получаемый результат в консоли, и только после этого запускайте
скрипт. В противном случае можно получить не тот результат, который ожидался, и придется откатывать изменения.

## Что корректно работает

Скрипт автоматически вносит правки в wml файлы. А также может вносить правки в ts tsx файлах.

Корректно обрабатываются следующие сценарии:

```js
import {Tumbler} from 'Controls/toggle';

<Tumbler/>
```

```js
import {Tumbler as View} from 'Controls/toggle';

<View/>
```

```js
import {default as toggle} from 'Controls/toggle';

<toggle.Tumbler/>
```

```js
import {Tumbler, Switch} from 'Controls/toggle';

<Tumbler/>
<Switch/>
```

Если из исходной библиотеки выносится 1 контрол, то скрипт сам создаст или найдет нужный импорт, и засунет туда новый
контрол

Что касается переименовывания опций, то скрипт обрабатывает все случаи. И работает как с wml, так и с tsx.

## Что нестабильно работает с заменой контролов

Сейчас есть проблемы с импортом следующего вида:

```js
import * as toggle from 'Controls/toggle';
```

Скрипт самостоятельно не сможет обработать подобные сценарии, на что кинет ошибку. Но при этом скрипт сможет внести
правки по использованию контрола, и заменит

```js
<toggle.Name>
```

на

```js
<toggle.NewName>
```

Скрипт не тронет сам импорт, так как он не знает нужно его заменить и как. Если вы полностью переносите весь модуль, то
можно указать это название в `replaces.newModule`, в таком случае скрипт заменит импорт для модуля. Свойство стоит
использовать тогда когда полностью переименовывается модуль, в противном случае скрипт отработает некорректно.

Также если контрол использовался так `Controls.LoadingIndicator`, а нужно превратить его в `Controls.loading:Indicator`,
то скрипт самостоятельно не сможет подобное обработать, а любая попытка провернуть подобное может обернуться ошибками.
Возможно, когда-то подобный функционал появится, но на данный момент в нем нет необходимости.

## Дополнительно

Через скрипт можно переименовывать различные утилиты, но есть вероятность что будет проблемы в редких случаях(см "Что
нестабильно работает").

Скрипт проходится по всем файлам в директории, но не смотрит файлы больше 50mb, но можно настроить другое ограничение
используя `maxFileSize`(не рекомендуется устанавливать большие значения)

О найденных проблемах или идеях по улучшению можно
писать [мне](https://online.sbis.ru/person/5bf5b206-a664-422b-b5e2-41217142717a)
