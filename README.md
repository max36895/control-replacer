# control-replacer
## Скрипт для автозамены

пока для удобства написан на js одним файлом. это сделано для того, чтобы можно было его тупо скопировать и вставить без сборки.

### Как работает
Необходимо скачать файл ```replacer.js``` а также создать json файл с настройкой для скрипта

#### Запускается скрипт следующим образом
```bash
node replacer.js config.json
```
#### JSON файл
Пример для замены Controls/toggle:Tumbler на Controls/toggle:NewTumbler
Файл JSON
```json
{
  "path": "",
  "replaces": [{
      "module": "Controls/toggle",
      "controls": [{
          "name": "Tumbler",
          "newName": "NewTumbler",
        }]
  }]
}
```
Если надо заменить Controls/toggle:Tumbler на Controls/Tumbler
```json
{
  "path": "",
  "replaces": [{
      "module": "Controls/toggle",
      "controls": [{
          "name": "Tumbler",
          "newName": "",
          "newModuleName": "Tumbler"
        }]
  }]
}
 ```
Важно чтобы в module разделение было сделано через ```/``` иначе возможна некорректная работа.
Также в ```controls``` можно не указывать newName и newModuleName, в таком случае значения проставятся из name и module.
Удобно использовать с том случае, если переименовывается только модуль или контролл.

Скрипт автоматически вносит правки в wml файлы. А также может вносить правки в ts tsx файлах
Корректно обрабатываются следующие сценарии:
```js
import {Tumbler} from 'Controls/toggle'
<Tumbler/>
```
```js
import {Tumbler as View} from 'Controls/toggle'
<View/>
```
```js
import default as toggle from 'Controls/toggle'
<toggle.Tumbler/>
```
```js
import {Tumbler, Switch} from 'Controls/toggle'
<Tumbler/>
<Switch/>
```
  
Если из исходной библиотеки выносится 1 контрол, то скрипт сам создаст или найдет нужный импорт, и засунет туда новый контрол

Сейчас есть проблемы с импортом следующего вида:
```js
import * as toggle from 'Controls/toggle';
```
Скрипт самостоятельно не сможет обработать подобные сценарии, на что кинет ошибку. Но при этом скрипт сможет внести правки по использованию контрола, и заменит
```js
<toggle.Name>
```
на
```js
<toggle.NewName>
```
скрипт не тронет сам импорт, так как он не значет стоит ли его заменить и как.
Если вы полностью переносите весь модуль, то можно указать это название в ```replaces.newModule```, в таком случае скрипт заменит импорт для модуля. Свойство стоит использовать только когда полностью переименовывается модуль, в противном случае скрипт отработает некорректно.

Также через скрипт можно переименовывать различные утилиты, но есть вероятность что-то будет проблемы в редких случаях.

На данный момент скрипт проходится чисто по всем файлам в директории, но не смотрит файлы больше 50mb, но можно настроить другое ограничение используя ```maxFileSize```(не рекомендуется устанавливать большее значение)

О найденых проблемах можно писать [мне](https://online.sbis.ru/person/5bf5b206-a664-422b-b5e2-41217142717a)
